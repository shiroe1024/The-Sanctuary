import logging
import json
import yt_dlp
import requests
from openai import OpenAI
import streamlit as st
import os
import requests

# --- CONFIG ---
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize OpenAI (Cloud or Local)
try:
    api_key = st.secrets.get("OPENAI_API_KEY", os.getenv("OPENAI_API_KEY"))
    client = OpenAI(api_key=api_key)
except Exception:
    client = None

# --- CONSTANTS ---
THE_ATLAS = {
    "Formal Sciences": ["Logic", "Mathematics", "Computer Science"],
    "Natural Sciences": ["Physics", "Chemistry", "Biology"],
    "Social Sciences": ["Economics", "Psychology", "Sociology"],
    "Humanities": ["Philosophy", "History", "Literature"],
    "Applied Sciences": ["Engineering", "Medicine", "Business"]
}

def get_transcript(video_id: str):
    """
    The 'Side Door' Method:
    Uses the Piped API (public YouTube proxy) to fetch subtitles.
    Bypasses YouTube's direct Region & IP blocks.
    """
    try:
        # 1. Ask Piped for the video metadata
        # Piped has multiple instances. We use the main stable one.
        api_url = f"https://pipedapi.kavin.rocks/streams/{video_id}"
        response = requests.get(api_url)
        
        if response.status_code != 200:
            return None
            
        data = response.json()
        
        # 2. Find the English Subtitle track
        subtitles = data.get('subtitles', [])
        subtitle_url = None
        
        for sub in subtitles:
            # We prefer 'en' (English) and auto-generated is fine if manual is missing
            if sub['code'] == 'en':
                subtitle_url = sub['url']
                if sub['autoGenerated'] is False: # Prefer manual if found
                    break
        
        if not subtitle_url:
            return None
            
        # 3. Fetch the actual text content
        # The URL provided by Piped is usually a .vtt file
        sub_response = requests.get(subtitle_url)
        
        if sub_response.status_code == 200:
            # Simple VTT cleanup (removing timestamps)
            raw_vtt = sub_response.text
            lines = raw_vtt.split('\n')
            # Filter out timestamps (lines with '-->') and empty lines
            clean_lines = [
                line.strip() 
                for line in lines 
                if '-->' not in line and line.strip() and not line.strip().isdigit() and line.strip() != 'WEBVTT'
            ]
            return " ".join(list(set(clean_lines))) # set() removes duplicates often found in VTT
            
        return None

    except Exception as e:
        print(f"Piped API Error: {e}")
        return None

def analyze_video(transcript: str):
    if not client: return None
    
    # Quick prompt to save tokens
    prompt = f"""
    Classify into Roots: {json.dumps(list(THE_ATLAS.keys()))}
    Create 3 verification questions (A,B,C) based on this text.
    OUTPUT JSON: {{ "root_category": "...", "questions": [...] }}
    TEXT: {transcript[:15000]}
    """

    try:
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            response_format={"type": "json_object"}
        )
        return json.loads(response.choices[0].message.content)
    except Exception:
        return None
